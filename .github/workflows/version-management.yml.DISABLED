name: Version Management and Release

on:
  push:
    branches: [ main, develop ]
    tags: ['v*']
  release:
    types: [ published, created ]
  pull_request:
    types: [ closed ]
    branches: [ main ]
  workflow_dispatch:
    inputs:
      version-type:
        description: 'Version type (major, minor, patch)'
        required: true
        type: choice
        options:
        - major
        - minor
        - patch
      environment:
        description: 'Target environment (staging, production)'
        required: true
        type: choice
        options:
        - staging
        - production
      pre-release:
        description: 'Mark as pre-release'
        required: false
        type: boolean
        default: false

env:
  NODE_VERSION: '20.x'

jobs:
  # 1. Version Validation
  version-validation:
    name: Version Validation
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true
    
    outputs:
      should-release: ${{ steps.check.outputs.should-release }}
      version-type: ${{ steps.check.outputs.version-type }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Check for version changes
      id: check
      run: |
        # Analyze commit messages to determine version type
        COMMITS=$(git log --oneline -n 10 --merges --no-merges)
        SHOULD_RELEASE="false"
        VERSION_TYPE="patch"
        
        # Check for breaking changes (major)
        if echo "$COMMITS" | grep -iE "(breaking|major|incompatible|api.*change)" > /dev/null; then
          VERSION_TYPE="major"
          SHOULD_RELEASE="true"
        fi
        
        # Check for new features (minor)
        if echo "$COMMITS" | grep -iE "(feat|feature|add|new)" > /dev/null; then
          VERSION_TYPE="minor"
          SHOULD_RELEASE="true"
        fi
        
        # Check for bug fixes (patch)
        if echo "$COMMITS" | grep -iE "(fix|bug|error|issue)" > /dev/null; then
          VERSION_TYPE="patch"
          SHOULD_RELEASE="true"
        fi
        
        echo "should-release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
        echo "version-type=$VERSION_TYPE" >> $GITHUB_OUTPUT

  # 2. Version Management
  version-management:
    name: Version Management
    runs-on: ubuntu-latest
    needs: [version-validation]
    if: >-
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true && needs.version-validation.outputs.should-release == 'true') ||
      github.event_name == 'release'
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      environment: ${{ steps.environment.outputs.environment }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Determine environment
      id: environment
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          ENVIRONMENT="${{ github.event.inputs.environment }}"
        elif [ "${{ github.event_name }}" == "pull_request" ]; then
          ENVIRONMENT="staging"
        else
          ENVIRONMENT="production"
        fi
        echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
        
    - name: Generate version
      id: version
      run: |
        # Get current version
        CURRENT_VERSION=$(node -p "require('./package.json').version")
        echo "Current version: $CURRENT_VERSION"
        
        # Determine version type
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          VERSION_TYPE="${{ github.event.inputs.version-type }}"
        elif [ "${{ github.event_name }}" == "pull_request" ]; then
          VERSION_TYPE="${{ needs.version-validation.outputs.version-type }}"
        elif [ "${{ github.event_name }}" == "release" ]; then
          # Extract version from tag
          VERSION_TYPE="patch"
        else
          # Default to patch for regular pushes
          VERSION_TYPE="patch"
        fi
        
        # Calculate new version
        if [ "$VERSION_TYPE" == "major" ]; then
          NEW_VERSION=$(node -p "const v = '${CURRENT_VERSION}'.split('.'); v[0] = parseInt(v[0]) + 1; v[1] = 0; v[2] = 0; v.join('.')")
        elif [ "$VERSION_TYPE" == "minor" ]; then
          NEW_VERSION=$(node -p "const v = '${CURRENT_VERSION}'.split('.'); v[1] = parseInt(v[1]) + 1; v[2] = 0; v.join('.')")
        else
          NEW_VERSION=$(node -p "const v = '${CURRENT_VERSION}'.split('.'); v[2] = parseInt(v[2]) + 1; v.join('.')")
        fi
        
        echo "New version: $NEW_VERSION"
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
        
    - name: Update package.json
      run: |
        NEW_VERSION="${{ steps.version.outputs.version }}"
        node -e "
          const pkg = require('./package.json');
          pkg.version = '$NEW_VERSION';
          require('fs').writeFileSync('./package.json', JSON.stringify(pkg, null, 2) + '\n');
        "
        
    - name: Update CHANGELOG.md
      run: |
        NEW_VERSION="${{ steps.version.outputs.version }}"
        DATE=$(date '+%Y-%m-%d')
        
        # Create changelog entry
        cat << 'EOF' > /tmp/changelog_entry.md
## [$NEW_VERSION] - $DATE

### Added
- New features and improvements

### Changed
- Existing features updated

### Fixed
- Bug fixes and improvements

### Security
- Security updates and patches

EOF
        
        # Update changelog
        if [ -f "CHANGELOG.md" ]; then
          cp CHANGELOG.md CHANGELOG.md.backup
          cat /tmp/changelog_entry.md > CHANGELOG.md
          echo "" >> CHANGELOG.md
          cat CHANGELOG.md.backup >> CHANGELOG.md
        else
          cp /tmp/changelog_entry.md CHANGELOG.md
        fi
        
    - name: Commit and push version updates
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        git add package.json CHANGELOG.md
        git commit -m "chore: Update version to ${{ steps.version.outputs.version }}"
        git push
        
    - name: Create and push tag
      run: |
        git tag -a "v${{ steps.version.outputs.version }}" -m "Release version ${{ steps.version.outputs.version }}"
        git push origin "v${{ steps.version.outputs.version }}"

  # 3. Release Management
  release-management:
    name: Release Management
    runs-on: ubuntu-latest
    needs: [version-management, version-validation]
    if: >-
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true && needs.version-validation.outputs.should-release == 'true') ||
      github.event_name == 'release'
    
    environment: ${{ needs.version-management.outputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run tests
      run: npm run ci:test
      
    - name: Build application
      run: npm run build
      
    - name: Security scan
      run: npm run ci:security
      
    - name: Create release artifacts
      run: |
        mkdir -p release-artifacts
        
        # Create zip archive
        zip -r release-artifacts/normaldance-v${{ steps.version-management.outputs.version }}.zip .next/ public/ dist/
        
        # Create tar.gz archive
        tar -czf release-artifacts/normaldance-v${{ steps.version-management.outputs.version }}.tar.gz .next/ public/ dist/
        
        # Create Docker image
        docker build -t normaldance:v${{ steps.version-management.outputs.version }} .
        docker save normaldance:v${{ steps.version-management.outputs.version }} | gzip > release-artifacts/normaldance-v${{ steps.version-management.outputs.version }}.docker.tar.gz
        
    - name: Upload release artifacts
      uses: actions/upload-artifact@v3
      with:
        name: release-artifacts
        path: release-artifacts/
        retention-days: 90
        
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ steps.version-management.outputs.version }}
        name: "NormalDance v${{ steps.version-management.outputs.version }}"
        body: |
          ## NormalDance v${{ steps.version-management.outputs.version }}
          
          ### Environment: ${{ needs.version-management.outputs.environment }}
          
          ### What's Changed
          - Version updates and improvements
          - Bug fixes and optimizations
          - Performance improvements
          
          ### Installation
          \`\`\`
          npm install normaldance@${{ steps.version-management.outputs.version }}
          \`\`\`
          
          ### Docker Image
          \`\`\`
          docker pull normaldance/normaldance:v${{ steps.version-management.outputs.version }}
          \`\`\`
          
          ### Documentation
          See the [CHANGELOG.md](CHANGELOG.md) for detailed information about this release.
          
          ### Support
          For support, please visit our [GitHub Issues](https://github.com/normaldance/normaldance/issues) or join our [Discord](https://discord.gg/normaldance).
        files: |
          release-artifacts/normaldance-v${{ steps.version-management.outputs.version }}.zip
          release-artifacts/normaldance-v${{ steps.version-management.outputs.version }}.tar.gz
          release-artifacts/normaldance-v${{ steps.version-management.outputs.version }}.docker.tar.gz
        draft: false
        prerelease: ${{ github.event.inputs.pre-release || false }}
        generate_release_notes: true

  # 4. Deployment
  deployment:
    name: Deploy to ${{ needs.version-management.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [version-management, release-management]
    if: needs.release-management.result == 'success'
    environment: ${{ needs.version-management.outputs.environment }}
    
    steps:
    - name: Download release artifacts
      uses: actions/download-artifact@v3
      with:
        name: release-artifacts
        path: release-artifacts/
        
    - name: Deploy to staging
      if: needs.version-management.outputs.environment == 'staging'
      run: |
        echo "Deploying to staging environment..."
        # Add staging deployment logic here
        # Example: Deploy to Vercel staging
        npm run deploy:vercel:staging
        
    - name: Deploy to production
      if: needs.version-management.outputs.environment == 'production'
      run: |
        echo "Deploying to production environment..."
        # Add production deployment logic here
        # Example: Deploy to Vercel production
        npm run deploy:vercel
        
    - name: Run smoke tests
      run: |
        echo "Running smoke tests..."
        npm run test:smoke
        
    - name: Health check
      run: |
        echo "Performing health check..."
        curl -f ${{ needs.version-management.outputs.environment == 'production' && 'https://dnb1st.ru' || 'https://staging.dnb1st.ru' }}/api/health

  # 5. Notification
  notification:
    name: Notification
    runs-on: ubuntu-latest
    needs: [version-management, release-management, deployment]
    if: always()
    
    steps:
    - name: Send notification
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        fields: repo,message,commit,author,action,eventName,ref,workflow
        custom_payload: |
          {
            "attachments": [
              {
                "color": "${{ needs.deployment.result == 'success' ? 'good' : needs.deployment.result == 'failure' ? 'danger' : 'warning' }}",
                "title": "Version Management - ${{ needs.version-management.outputs.environment }}",
                "title_link": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
                "text": "Version ${{ needs.version-management.outputs.version }} ${{ needs.deployment.result == 'success' ? 'deployed successfully' : 'deployment failed' }}!",
                "fields": [
                  {
                    "title": "Repository",
                    "value": "${{ github.repository }}",
                    "short": true
                  },
                  {
                    "title": "Version",
                    "value": "${{ needs.version-management.outputs.version }}",
                    "short": true
                  },
                  {
                    "title": "Tag",
                    "value": "${{ needs.version-management.outputs.tag }}",
                    "short": true
                  },
                  {
                    "title": "Environment",
                    "value": "${{ needs.version-management.outputs.environment }}",
                    "short": true
                  },
                  {
                    "title": "Deployment",
                    "value": "${{ needs.deployment.result }}",
                    "short": true
                  }
                ]
              }
            ]
          }