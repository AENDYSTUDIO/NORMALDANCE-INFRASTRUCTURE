# Руководство по безопасности файлов окружения

## Обзор

Этот документ описывает лучшие практики по управлению файлами окружения (.env) и секретами в проекте NORMALDANCE.

## Текущее состояние

### Обнаруженные проблемы:

1. Файл `.env.local` содержит реальные секреты (PINATA_API_KEY, PINATA_SECRET_KEY, PINATA_JWT)
2. В `.gitignore` строка `.env*` исключает все .env файлы, но могут быть исключения
3. В файле `.env` и `.env.local` содержатся потенциально чувствительные данные
4. Некоторые секреты в `.env.local` выглядят как реальные (длинные строки, JWT токены)

### Угрозы безопасности:

1. Попадание реальных секретов в репозиторий
2. Использование слабых или предсказуемых секретов
3. Отсутствие регулярной ротации секретов
4. Потенциальная утечка через логи или ошибки

## Рекомендации по безопасности

### 1. Файлы .env

#### .env.example

- Должен содержать только шаблоны переменных с понятными описаниями
- Все значения должны быть фиктивными или заполнителями
- Должен включать все необходимые переменные для работы приложения
- Должен быть обновлен регулярно при добавлении новых зависимостей

#### .env.local (локальная разработка)

- Должен быть включен в .gitignore и НЕ должен попадать в репозиторий
- Может содержать реальные секреты для локальной разработки
- Секреты должны быть валидными, но для изолированной среды
- Должен быть документирован процесс получения этих секретов

#### .env (production/стaging)

- НЕ должен попадать в репозиторий
- Управление через CI/CD системы или внешние провайдеры секретов
- Должен использовать отдельные секреты для каждой среды

### 2. Проверка .gitignore

Текущая строка `.env*` в .gitignore корректно исключает все файлы .env, что является хорошей практикой. Однако рекомендуется:

```gitignore
# Исключить все .env файлы
.env*
# Но при необходимости можно включить .env.example
!.env.example
```

### 3. Типы секретов и рекомендации по их безопасности

#### API Ключи

- PINATA_API_KEY, PINATA_SECRET_KEY: должны регулярно ротироваться
- OPENAI_API_KEY, LANGGRAPH_API_KEY: использовать отдельные ключи для разных сред
- Все API ключи должны быть минимально необходимыми для работы

#### JWT и аутентификация

- NEXTAUTH_SECRET: должен быть сгенерирован с использованием криптографически безопасного генератора
- JWT_SECRET: должен быть длиной не менее 32 символов и содержать случайные символы

#### Web3 программы

- NEXT_PUBLIC_NDT_PROGRAM_ID, NEXT_PUBLIC_TRACKNFT_PROGRAM_ID: должны быть проверены на соответствие реальным адресам
- Значения должны быть обновлены для продакшена

### 4. Рекомендуемые действия

#### Немедленные действия:

1. Проверить и удалить из репозитория любые файлы .env, содержащие реальные секреты
2. Обновить .env.example с лучшими примерами и описаниями
3. Проверить .env.local и убедиться, что он не попадает в коммиты
4. Создать скрипт проверки на наличие секретов в коммитах

#### Долгосрочные действия:

1. Внедрить систему управления секретами (например, HashiCorp Vault, AWS Secrets Manager)
2. Автоматизировать ротацию секретов
3. Внедрить проверку утечки секретов в CI/CD
4. Обучить команду безопасности работы с секретами

### 5. Скрипты безопасности

#### Проверка на утечку секретов:

```bash
# Проверить историю git на наличие потенциальных секретов
git log --all --full-history -- "*.env" -- "*secret*" -- "*key*" -- "*token*"
```

#### Проверка содержимого файлов:

Создать скрипт `scripts/check-hardcoded-secrets.js` для проверки потенциальных утечек.

### 6. Лучшие практики

1. **Минимизация**: используйте только необходимые переменные окружения
2. **Именование**: используйте понятные имена с префиксами (NEXT*PUBLIC* для клиентских переменных)
3. **Документирование**: каждый параметр должен быть задокументирован
4. **Ротация**: регулярно меняйте секреты, особенно в production
5. **Изоляция**: используйте разные секреты для разных сред (dev, staging, prod)

### 7. Проверка конфигурации

#### Скрипт валидации:

```javascript
// scripts/validate-env.js
const fs = require("fs");
const path = require("path");

function validateEnvFile(envPath) {
  if (!fs.existsSync(envPath)) {
    console.log(`Файл ${envPath} не найден`);
    return false;
  }

  const content = fs.readFileSync(envPath, "utf8");
  const lines = content.split("\n");

  let isValid = true;

  for (const line of lines) {
    if (line.trim() && !line.startsWith("#")) {
      const [key, value] = line.split("=");
      if (key && value) {
        // Проверить, что значение не является реальным секретом в .env.example
        if (envPath === ".env.example" && isRealSecret(value)) {
          console.log(`Потенциальная утечка в ${envPath}: ${key}`);
          isValid = false;
        }
      }
    }
  }

  return isValid;
}

function isRealSecret(value) {
  // Проверка на наличие реальных секретов в .env.example
  const realSecretPatterns = [
    /^[a-f0-9]{64}$/, // 64-символьные хеши
    /^ey[a-zA-Z0-9_=-]+$/, // JWT начало
    /^[a-zA-Z0-9]{32,}$/, // Длинные строки без очевидных паттернов
  ];

  return realSecretPatterns.some((pattern) => pattern.test(value.trim()));
}

// Проверить .env.example
validateEnvFile(".env.example");
```

## Заключение

Безопасное управление файлами окружения критически важно для безопасности проекта. Регулярная проверка и обновление этих файлов, а также внедрение автоматизированных проверок, помогут предотвратить утечку чувствительных данных.
