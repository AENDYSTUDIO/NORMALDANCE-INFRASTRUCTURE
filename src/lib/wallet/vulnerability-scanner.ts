import { Keypair, PublicKey, Transaction, Connection } from '@solana/web3.js';
import { WalletAdapter } from '../../components/wallet/wallet-adapter';
import { SecurityManager } from './security-manager';
import { Logger } from '../utils/logger';

/**
 * Сканер уязвимостей для Invisible Wallet
 * Автоматически сканирует систему на наличие уязвимостей,
 * проверяет на известные векторы атак, оценивает уровень риска
 * и предоставляет рекомендации по устранению
 */
export class VulnerabilityScanner {
  private logger: Logger;
  private securityManager: SecurityManager;
  private knownVulnerabilities: Map<string, { severity: 'critical' | 'high' | 'medium' | 'low'; description: string; fix: string }> = new Map();

  constructor() {
    this.logger = new Logger('VulnerabilityScanner');
    this.securityManager = new SecurityManager();
    this.initializeKnownVulnerabilities();
  }

  /**
   * Инициализация базы известных уязвимостей
   */
  private initializeKnownVulnerabilities(): void {
    // Уязвимости хранения ключей
    this.knownVulnerabilities.set('KEY_STORAGE_IN_MEMORY', {
      severity: 'critical',
      description: 'Приватные ключи хранятся в оперативной памяти в открытом виде',
      fix: 'Использовать защищенное хранилище ключей с шифрованием'
    });

    this.knownVulnerabilities.set('KEY_LOGGING', {
      severity: 'critical',
      description: 'Ключи записываются в логи или отладочную информацию',
      fix: 'Обеспечить фильтрацию ключей из логов и отладочной информации'
    });

    // Уязвимости аутентификации
    this.knownVulnerabilities.set('WEAK_AUTH', {
      severity: 'high',
      description: 'Слабые методы аутентификации или отсутствие многофакторной аутентификации',
      fix: 'Реализовать многофакторную аутентификацию и усиленные методы проверки подлинности'
    });

    this.knownVulnerabilities.set('SESSION_FIXATION', {
      severity: 'high',
      description: 'Уязвимость к атакам фиксации сессии',
      fix: 'Регенерировать идентификаторы сессии после аутентификации'
    });

    // Уязвимости транзакций
    this.knownVulnerabilities.set('REPLAY_ATTACK', {
      severity: 'high',
      description: 'Уязвимость к атакам повторного воспроизведения транзакций',
      fix: 'Реализовать механизмы предотвращения повторного использования транзакций'
    });

    this.knownVulnerabilities.set('TRANSACTION_MALLEABILITY', {
      severity: 'medium',
      description: 'Возможность модификации транзакций до подтверждения',
      fix: 'Использовать защищенные форматы транзакций с неизменяемыми хэшами'
    });

    // Уязвимости сети
    this.knownVulnerabilities.set('MAN_IN_THE_MIDDLE', {
      severity: 'high',
      description: 'Уязвимость к атакам "человек посередине"',
      fix: 'Обеспечить надежное шифрование соединений и проверку сертификатов'
    });

    this.knownVulnerabilities.set('NODE_IMPERSONATION', {
      severity: 'high',
      description: 'Возможность имитации узлов блокчейна',
      fix: 'Реализовать надежную проверку подлинности узлов'
    });

    // Уязвимости фишинга
    this.knownVulnerabilities.set('PHISHING_INTERFACE', {
      severity: 'high',
      description: 'Интерфейс уязвим к фишинговым атакам',
      fix: 'Добавить визуальные индикаторы подлинности и проверку домена'
    });

    this.knownVulnerabilities.set('TRANSACTION_PHISHING', {
      severity: 'critical',
      description: 'Возможность подмены транзакций для фишинга',
      fix: 'Реализовать детальную проверку транзакций перед подписанием'
    });
  }

  /**
   * Сканирование уязвимостей хранения ключей
   * @param keypair - Keypair для проверки
   * @returns Результат сканирования
   */
  async scanForKeyStorageVulnerabilities(keypair: Keypair): Promise<{ vulnerabilities: string[]; riskLevel: 'low' | 'medium' | 'high' | 'critical' }> {
    const vulnerabilities: string[] = [];
    
    try {
      // Проверка на утечку ключей в память
      if (this.securityManager.isKeyExposed(keypair)) {
        vulnerabilities.push('KEY_STORAGE_IN_MEMORY');
      }

      // Проверка на небезопасное хранение ключей
      if (!this.securityManager.isSecureStorage(keypair)) {
        vulnerabilities.push('KEY_LOGGING');
      }

      // Проверка на уязвимость к XSS
      if (this.securityManager.isXSSVulnerable(keypair)) {
        vulnerabilities.push('KEY_LOGGING');
      }

      // Определяем уровень риска на основе найденных уязвимостей
      const riskLevel = this.calculateRiskLevel(vulnerabilities);
      
      this.logger.info(`Key storage vulnerability scan completed. Found ${vulnerabilities.length} vulnerabilities`);
      return { vulnerabilities, riskLevel };
    } catch (error) {
      this.logger.error('Error during key storage vulnerability scan', error);
      return { vulnerabilities: ['SCAN_ERROR'], riskLevel: 'critical' };
    }
  }

  /**
   * Сканирование уязвимостей фишинга
   * @returns Результат сканирования
   */
  async scanForPhishingVulnerabilities(): Promise<{ vulnerabilities: string[]; riskLevel: 'low' | 'medium' | 'high' | 'critical' }> {
    const vulnerabilities: string[] = [];
    
    try {
      // Проверка на отсутствие проверки домена
      if (!this.securityManager.isValidDomain()) {
        vulnerabilities.push('PHISHING_INTERFACE');
      }

      // Проверка на отсутствие проверки SSL сертификата
      if (!this.securityManager.isValidSSL()) {
        vulnerabilities.push('MAN_IN_THE_MIDDLE');
      }

      // Проверка на уязвимость интерфейса к фишингу
      if (!this.securityManager.isUIPhishingProtected()) {
        vulnerabilities.push('PHISHING_INTERFACE');
      }

      // Проверка на уязвимость транзакций к фишингу
      if (!this.securityManager.isTransactionPhishingProtected()) {
        vulnerabilities.push('TRANSACTION_PHISHING');
      }

      // Определяем уровень риска
      const riskLevel = this.calculateRiskLevel(vulnerabilities);
      
      this.logger.info(`Phishing vulnerability scan completed. Found ${vulnerabilities.length} vulnerabilities`);
      return { vulnerabilities, riskLevel };
    } catch (error) {
      this.logger.error('Error during phishing vulnerability scan', error);
      return { vulnerabilities: ['SCAN_ERROR'], riskLevel: 'critical' };
    }
  }

  /**
   * Сканирование уязвимостей аутентификации
   * @param walletAdapter - Адаптер кошелька
   * @returns Результат сканирования
   */
  async scanForAuthenticationVulnerabilities(walletAdapter: WalletAdapter): Promise<{ vulnerabilities: string[]; riskLevel: 'low' | 'medium' | 'high' | 'critical' }> {
    const vulnerabilities: string[] = [];
    
    try {
      // Проверка на отсутствие защиты от перебора
      if (!this.securityManager.isBruteForceProtected()) {
        vulnerabilities.push('WEAK_AUTH');
      }

      // Проверка на отсутствие защиты от атак на сессии
      if (!this.securityManager.isSessionAttackProtected()) {
        vulnerabilities.push('SESSION_FIXATION');
      }

      // Проверка на отсутствие защиты от атак с повторным использованием токенов
      if (!this.securityManager.isTokenReplayProtected()) {
        vulnerabilities.push('WEAK_AUTH');
      }

      // Проверка на слабую аутентификацию устройства
      if (!this.securityManager.isDeviceAuthenticationValid()) {
        vulnerabilities.push('WEAK_AUTH');
      }

      // Определяем уровень риска
      const riskLevel = this.calculateRiskLevel(vulnerabilities);
      
      this.logger.info(`Authentication vulnerability scan completed. Found ${vulnerabilities.length} vulnerabilities`);
      return { vulnerabilities, riskLevel };
    } catch (error) {
      this.logger.error('Error during authentication vulnerability scan', error);
      return { vulnerabilities: ['SCAN_ERROR'], riskLevel: 'critical' };
    }
  }

  /**
   * Сканирование уязвимостей целостности данных
   * @param transaction - Транзакция для проверки
   * @param connection - Подключение к Solana
   * @returns Результат сканирования
   */
  async scanForDataIntegrityVulnerabilities(transaction: Transaction, connection: Connection): Promise<{ vulnerabilities: string[]; riskLevel: 'low' | 'medium' | 'high' | 'critical' }> {
    const vulnerabilities: string[] = [];
    
    try {
      // Проверка на отсутствие проверки целостности транзакции
      if (!this.securityManager.verifyTransactionIntegrity(transaction)) {
        vulnerabilities.push('TRANSACTION_MALLEABILITY');
      }

      // Проверка на уязвимость к подделке данных
      if (!this.securityManager.isDataTamperingProtected(transaction)) {
        vulnerabilities.push('TRANSACTION_MALLEABILITY');
      }

      // Проверка на уязвимость на уровне блокчейна
      if (!this.securityManager.isBlockchainLevelSecure(transaction, connection)) {
        vulnerabilities.push('NODE_IMPERSONATION');
      }

      // Определяем уровень риска
      const riskLevel = this.calculateRiskLevel(vulnerabilities);
      
      this.logger.info(`Data integrity vulnerability scan completed. Found ${vulnerabilities.length} vulnerabilities`);
      return { vulnerabilities, riskLevel };
    } catch (error) {
      this.logger.error('Error during data integrity vulnerability scan', error);
      return { vulnerabilities: ['SCAN_ERROR'], riskLevel: 'critical' };
    }
  }

  /**
   * Сканирование сетевых уязвимостей
   * @returns Результат сканирования
   */
  async scanForNetworkVulnerabilities(): Promise<{ vulnerabilities: string[]; riskLevel: 'low' | 'medium' | 'high' | 'critical' }> {
    const vulnerabilities: string[] = [];
    
    try {
      // Проверка на уязвимость к MITM атакам
      if (!this.securityManager.isNetworkLevelSecure(new Transaction())) {
        vulnerabilities.push('MAN_IN_THE_MIDDLE');
      }

      // Проверка на уязвимость к атакам на уровне протокола
      if (!this.securityManager.isProtocolLevelSecure(new Transaction())) {
        vulnerabilities.push('MAN_IN_THE_MIDDLE');
      }

      // Определяем уровень риска
      const riskLevel = this.calculateRiskLevel(vulnerabilities);
      
      this.logger.info(`Network vulnerability scan completed. Found ${vulnerabilities.length} vulnerabilities`);
      return { vulnerabilities, riskLevel };
    } catch (error) {
      this.logger.error('Error during network vulnerability scan', error);
      return { vulnerabilities: ['SCAN_ERROR'], riskLevel: 'critical' };
    }
  }

  /**
   * Сканирование уязвимостей на уровне браузера
   * @returns Результат сканирования
   */
  async scanForBrowserVulnerabilities(): Promise<{ vulnerabilities: string[]; riskLevel: 'low' | 'medium' | 'high' | 'critical' }> {
    const vulnerabilities: string[] = [];
    
    try {
      // Проверка на уязвимость к XSS
      if (this.securityManager.isUIXSSVulnerable()) {
        vulnerabilities.push('KEY_LOGGING');
      }

      // Проверка на уязвимость к CSRF
      if (this.securityManager.isAuthCSRFVulnerable()) {
        vulnerabilities.push('WEAK_AUTH');
      }

      // Проверка на уязвимость хранилища
      if (this.securityManager.isLocalStorageVulnerable()) {
        vulnerabilities.push('KEY_STORAGE_IN_MEMORY');
      }

      // Определяем уровень риска
      const riskLevel = this.calculateRiskLevel(vulnerabilities);
      
      this.logger.info(`Browser vulnerability scan completed. Found ${vulnerabilities.length} vulnerabilities`);
      return { vulnerabilities, riskLevel };
    } catch (error) {
      this.logger.error('Error during browser vulnerability scan', error);
      return { vulnerabilities: ['SCAN_ERROR'], riskLevel: 'critical' };
    }
  }

  /**
   * Сканирование уязвимостей на уровне устройства
   * @returns Результат сканирования
   */
  async scanForDeviceVulnerabilities(): Promise<{ vulnerabilities: string[]; riskLevel: 'low' | 'medium' | 'high' | 'critical' }> {
    const vulnerabilities: string[] = [];
    
    try {
      // Проверка на уязвимость к root-атакам
      if (this.securityManager.isRootAccessVulnerable()) {
        vulnerabilities.push('KEY_STORAGE_IN_MEMORY');
      }

      // Проверка на уязвимость к атакам через файловую систему
      if (this.securityManager.isFileSystemVulnerable()) {
        vulnerabilities.push('KEY_STORAGE_IN_MEMORY');
      }

      // Определяем уровень риска
      const riskLevel = this.calculateRiskLevel(vulnerabilities);
      
      this.logger.info(`Device vulnerability scan completed. Found ${vulnerabilities.length} vulnerabilities`);
      return { vulnerabilities, riskLevel };
    } catch (error) {
      this.logger.error('Error during device vulnerability scan', error);
      return { vulnerabilities: ['SCAN_ERROR'], riskLevel: 'critical' };
    }
  }

  /**
   * Полное сканирование всех типов уязвимостей
   * @returns Полный отчет о сканировании
   */
  async scanAll(): Promise<{
    vulnerabilities: Array<{ id: string; severity: string; description: string; fix: string }>;
    scanDate: Date;
    summary: {
      total: number;
      critical: number;
      high: number;
      medium: number;
      low: number;
    };
  }> {
    this.logger.info('Starting full vulnerability scan');
    
    const allVulnerabilities: Array<{ id: string; severity: string; description: string; fix: string }> = [];
    
    // Выполняем все сканирования
    const keyStorageVulns = await this.scanForKeyStorageVulnerabilities(new Keypair());
    const phishingVulns = await this.scanForPhishingVulnerabilities();
    const authVulns = await this.scanForAuthenticationVulnerabilities(new WalletAdapter() as any);
    const dataIntegrityVulns = await this.scanForDataIntegrityVulnerabilities(new Transaction(), new Connection('http://localhost:899'));
    const networkVulns = await this.scanForNetworkVulnerabilities();
    const browserVulns = await this.scanForBrowserVulnerabilities();
    const deviceVulns = await this.scanForDeviceVulnerabilities();
    
    // Объединяем все уязвимости
    [...keyStorageVulns.vulnerabilities, ...phishingVulns.vulnerabilities, 
     ...authVulns.vulnerabilities, ...dataIntegrityVulns.vulnerabilities,
     ...networkVulns.vulnerabilities, ...browserVulns.vulnerabilities,
     ...deviceVulns.vulnerabilities]
     .forEach(vulnId => {
       if (this.knownVulnerabilities.has(vulnId)) {
         const vuln = this.knownVulnerabilities.get(vulnId)!;
         allVulnerabilities.push({
           id: vulnId,
           severity: vuln.severity,
           description: vuln.description,
           fix: vuln.fix
         });
       }
     });
    
    // Подсчитываем статистику
    const summary = {
      total: allVulnerabilities.length,
      critical: allVulnerabilities.filter(v => v.severity === 'critical').length,
      high: allVulnerabilities.filter(v => v.severity === 'high').length,
      medium: allVulnerabilities.filter(v => v.severity === 'medium').length,
      low: allVulnerabilities.filter(v => v.severity === 'low').length,
    };
    
    this.logger.info(`Full vulnerability scan completed. Found ${summary.total} vulnerabilities`);
    
    return {
      vulnerabilities: allVulnerabilities,
      scanDate: new Date(),
      summary
    };
  }

  /**
   * Сканирование конкретного компонента системы
   * @param component - Компонент для сканирования
   * @param walletAdapter - Адаптер кошелька (если требуется)
   * @returns Результат сканирования
   */
  async scanComponent(component: 'keys' | 'auth' | 'transactions' | 'network' | 'storage' | 'interface', 
                     walletAdapter?: WalletAdapter): Promise<{ vulnerabilities: string[]; riskLevel: 'low' | 'medium' | 'high' | 'critical' }> {
    switch (component) {
      case 'keys':
        return await this.scanForKeyStorageVulnerabilities(walletAdapter?.keypair || new Keypair());
      case 'auth':
        if (!walletAdapter) {
          throw new Error('WalletAdapter required for authentication scanning');
        }
        return await this.scanForAuthenticationVulnerabilities(walletAdapter);
      case 'transactions':
        return await this.scanForDataIntegrityVulnerabilities(new Transaction(), 
          walletAdapter?.connection || new Connection('http://localhost:8899'));
      case 'network':
        return await this.scanForNetworkVulnerabilities();
      case 'storage':
        return await this.scanForBrowserVulnerabilities();
      case 'interface':
        return await this.scanForPhishingVulnerabilities();
      default:
        throw new Error(`Unknown component: ${component}`);
    }
  }

  /**
   * Оценка уровня риска на основе найденных уязвимостей
   * @param vulnerabilities - Массив идентификаторов уязвимостей
   * @returns Уровень риска
   */
  private calculateRiskLevel(vulnerabilities: string[]): 'low' | 'medium' | 'high' | 'critical' {
    if (vulnerabilities.length === 0) {
      return 'low';
    }
    
    // Подсчитываем количество уязвимостей по уровню критичности
    const criticalCount = vulnerabilities.filter(id => 
      this.knownVulnerabilities.has(id) && 
      this.knownVulnerabilities.get(id)!.severity === 'critical').length;
    
    const highCount = vulnerabilities.filter(id => 
      this.knownVulnerabilities.has(id) && 
      this.knownVulnerabilities.get(id)!.severity === 'high').length;
    
    if (criticalCount > 0) {
      return 'critical';
    } else if (highCount > 0 || criticalCount + highCount > 2) {
      return 'high';
    } else if (vulnerabilities.length > 5) {
      return 'high';
    } else if (vulnerabilities.length > 2) {
      return 'medium';
    } else {
      return 'low';
    }
  }

  /**
   * Получение рекомендаций по устранению уязвимостей
   * @param vulnerabilities - Массив идентификаторов уязвимостей
   * @returns Рекомендации по устранению
   */
  getFixRecommendations(vulnerabilities: string[]): Array<{ id: string; fix: string; priority: 'high' | 'medium' | 'low' }> {
    return vulnerabilities
      .filter(id => this.knownVulnerabilities.has(id))
      .map(id => {
        const vuln = this.knownVulnerabilities.get(id)!;
        return {
          id,
          fix: vuln.fix,
          priority: vuln.severity === 'critical' ? 'high' : 
                   vuln.severity === 'high' ? 'high' : 
                   vuln.severity === 'medium' ? 'medium' : 'low'
        };
      });
  }
}